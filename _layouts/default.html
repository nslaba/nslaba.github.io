<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natalie Slaba</title>
    <link rel="stylesheet" href="style.css">
    <script defer src="scripts.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <header>
        <h1>Natalie Slaba</h1>
    </header>
    <main>
        <section class="description">
            <p1>Welcome to my personal website for creative computer science projects. I'm not a web developer, so bear with me. <br><br><br><br><br><br>
                I hold a Bachelor of Science in Computer Science and Visual Arts from the University of Victoria (spring 2024).<br><br>
                I have a strong interest in discrete mathematics, computer graphics, natural languages, visual arts, and other creative pursuits. 
                Lately, I have also been exploring soldering and electronics.<br> In essence, I love to make things and solve problems. <br>I get excited about elegant solutions,
                whether they are visual, abstract, logical or hands-on. <br><br><br><br><br><br>
                This website serves as a repository for my innovative computer science projects. <br><br> <br><br>
            </p1>
            
        </section>
        <section class="projects">
            <div class="project" id="webgl">
                <img src="projects/webGL/animation/snapshot.png" alt="WebGL Project">
                <h2><a href="projects/webGL/animation/main.html">WebGL</a></h2>
            </div>
            <div class="project" id="opengl">
                <img src="projects/OpenGL/HermiteSpline/hermiteSpline.gif" alt="OpenGL Project">
                <h2><a href="projects/OpengGL/opengl.html">OpenGL</a></h2>
            </div>
            <div class="project" id="vulkan">
                <img src="projects/vulkan.jpg" alt="Vulkan Project">
                <h2><a href="projects/vulkan.html">Vulkan</a></h2>
            </div>
            <div class="project" id="Raytracer">
                <img src="projects/Raytracer/snapshot.png" alt="Raytracer Project">
                <h2><a href="projects/RayTracer/RayTracer.html">Raytracer</a></h2>
            </div>
            <div class="project" id="Arduino Projects">
                <img src="projects/Arduino/LEDs.jpg" alt="Arduino projects">
                <h2><a href="projects/Arduino/Arduino.html">Arduino projects</a></h2>
            </div>
        </section>
    </main>

    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
             
        in vec4 a_position;
        
        out vec2 v_uv;
        void main() {
            
            v_uv = a_position.xy * 0.5 + 0.5; // normalize to [0,1]
            gl_Position = a_position;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        uniform vec2 u_resolution;
        uniform float u_time;
            
        in vec2 v_uv; 
        out vec4 outColor;
            
        #define SMOOTH_STEP(a,b,t) smoothstep(a,b,t)
        #define ROTATION_ANGLE -0.785398
        #define SCALE .25
        #define SHOOTING_STAR_VELOCITY 2.
            
        float rand(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        float starShape(vec2 position, vec2 starPosition, float size, float brightness) {
            float distance = length(position - starPosition);
            return SMOOTH_STEP(size, size - 0.01, distance) * brightness;
        }
        
        float noise(vec2 p) {
            p = fract(p * vec2(233.34, 851.73));
            p += dot(p, p + 23.45);
            return fract(p.x * p.y);
        }
        
        float distanceToLine(vec2 p, vec2 a, vec2 b) {
            vec2 pa = p - a;
            vec2 ba = b - a;
            float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
            return length(pa - ba * t);
        }
        
        float drawLine(vec2 p, vec2 a, vec2 b) {
            float distance = distanceToLine(p, a, b);
            float intensity = SMOOTH_STEP(.0025, .00001, distance);
            float lineLength = length(a - b);
            intensity *= SMOOTH_STEP(1., .5, lineLength) + SMOOTH_STEP(.04, .03, abs(lineLength - .75));
            return intensity;
        }
        
        float createShootingStar(vec2 uv) {
            vec2 gridPosition = fract(uv) - .5;
            vec2 cellId = floor(uv);
            float h = noise(cellId);
            float line = drawLine(gridPosition, vec2(0., h), vec2(.125, h));
            float trail = SMOOTH_STEP(.14, .0, gridPosition.x);
            return line * trail;
        }
        
        void main() {
            vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
            vec2 st = v_uv * u_resolution / max(u_resolution.x, u_resolution.y);
        
            vec3 color = vec3(0.0);
        
            // Normal stars
            int numStars = 1000;
            for (int i = 0; i < numStars; i++) {
                vec2 starPos = vec2(rand(vec2(i, 0.0)), rand(vec2(i, 1.0)));
                float size = rand(vec2(i, 2.0)) * 0.008 + 0.002;
                float brightness = rand(vec2(i, 3.0)) * 0.8 + 0.2;
                brightness *= sin(u_time * 3.8 + float(i)) * 0.5 + 0.5; // Twinkling effect
                color += vec3(starShape(st, starPos, size, brightness));
            }
        
            // Shooting stars
            float t = u_time * SHOOTING_STAR_VELOCITY;
            vec2 uv = (v_uv * u_resolution - 0.5 * u_resolution) / u_resolution.y;
            vec2 transformedUv1 = vec2(uv.x - t, uv.y + t);
            transformedUv1.x *= 1.1;
            float angle = 3. * ROTATION_ANGLE;
            float sine = sin(angle);
            float cosine = cos(angle);
            mat2 rotationMatrix = mat2(cosine, -sine, sine, cosine);
            transformedUv1 *= rotationMatrix;
            transformedUv1 *= SCALE * .9;
            vec2 transformedUv2 = uv + t * 1.2;
            transformedUv2.x *= 1.1;
            angle = ROTATION_ANGLE;
            sine = sin(angle);
            cosine = cos(angle);
            rotationMatrix = mat2(cosine, -sine, sine, cosine);
            transformedUv2 *= rotationMatrix;
            transformedUv2 *= SCALE * 1.1;
            float shootingStar1 = createShootingStar(transformedUv1);
            float shootingStar2 = createShootingStar(transformedUv2);
            color += vec3(clamp(shootingStar1 + shootingStar2, 0., 1.));
        
            outColor = vec4(color, 1.0);
        }

        //precision mediump float;
        //        
        //uniform vec2 u_resolution;
        //uniform float u_time;
        //        
        //in vec2 v_uv; 
        //out vec4 outColor;
        //        
        //#define S(a,b,t) smoothstep(a,b,t)
        //#define ROT -0.785398
        //#define ZOOM .25
        //#define STAR_SPEED 2.
        //        
        //float random(vec2 st) {
        //    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        //}
        //
        //float star(vec2 position, vec2 starPosition, float size, float brightness) {
        //    float d = length(position - starPosition);
        //    return smoothstep(size, size - 0.01, d) * brightness;
        //}
        //
        //float N21(vec2 p) {
        //    p = fract(p * vec2(233.34, 851.73));
        //    p += dot(p, p + 23.45);
        //    return fract(p.x * p.y);
        //}
        //
        //float DistLine(vec2 p, vec2 a, vec2 b) {
        //    vec2 pa = p - a;
        //    vec2 ba = b - a;
        //    float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
        //    return length(pa - ba * t);
        //}
        //
        //float DrawLine(vec2 p, vec2 a, vec2 b) {
        //    float d = DistLine(p, a, b);
        //    float m = S(.0025, .00001, d);
        //    float d2 = length(a - b);
        //    m *= S(1., .5, d2) + S(.04, .03, abs(d2 - .75));
        //    return m;
        //}
        //
        //float ShootingStar(vec2 uv) {
        //    vec2 gv = fract(uv) - .5;
        //    vec2 id = floor(uv);
        //    float h = N21(id);
        //    float line = DrawLine(gv, vec2(0., h), vec2(.125, h));
        //    float trail = S(.14, .0, gv.x);
        //    return line * trail;
        //}
        //
        //void main() {
        //    vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
        //    vec2 st = v_uv * u_resolution / max(u_resolution.x, u_resolution.y);
        //
        //    vec3 color = vec3(0.0);
        //
        //    // Normal stars
        //    int numNormalStars = 1000;
        //    for (int i = 0; i < numNormalStars; i++) {
        //        vec2 starPos = vec2(random(vec2(i, 0.0)), random(vec2(i, 1.0)));
        //        float size = random(vec2(i, 2.0)) * 0.008 + 0.002;
        //        float brightness = random(vec2(i, 3.0)) * 0.8 + 0.2;
        //        brightness *= sin(u_time*3.8 + float(i)) * 0.5 + 0.5; // Twinkling effect
        //        //brightness += 0.5;
        //        color += vec3(star(st, starPos, size, brightness));
        //    }
        //
        //    // Shooting stars
        //    float t = u_time * STAR_SPEED;
        //    vec2 uv = (v_uv * u_resolution - 0.5 * u_resolution) / u_resolution.y;
        //    vec2 rv1 = vec2(uv.x - t, uv.y + t);
        //    rv1.x *= 1.1;
        //    float r = 3. * ROT;
        //    float s = sin(r);
        //    float c = cos(r);
        //    mat2 rot = mat2(c, -s, s, c);
        //    rv1 *= rot;
        //    rv1 *= ZOOM * .9;
        //    vec2 rv2 = uv + t * 1.2;
        //    rv2.x *= 1.1;
        //    r = ROT;
        //    s = sin(r);
        //    c = cos(r);
        //    rot = mat2(c, -s, s, c);
        //    rv2 *= rot;
        //    rv2 *= ZOOM * 1.1;
        //    float star1 = ShootingStar(rv1);
        //    float star2 = ShootingStar(rv2);
        //    color += vec3(clamp(star1 + star2, 0., 1.));
        //
        //    outColor = vec4(color, 1.0);
        //}

   
        
    </script>
    <script src="scripts.js"></script>
</body>
</html>



