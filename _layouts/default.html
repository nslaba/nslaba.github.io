<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Natalie Slaba</title>
    <link rel="stylesheet" href="style.css">
    <script defer src="scripts.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
</head>
<body>
    <canvas id="glcanvas"></canvas>
    <header>
        <h1>Natalie Slaba</h1>
    </header>
    <main>
        <section class="description">
            <p1>Welcome to my personal website for creative computer science projects. I'm not a web developer, so bear with me. <br><br><br><br><br><br>
                I hold a Bachelor of Science in Computer Science and Visual Arts from the University of Victoria (spring 2024).<br><br>
                I have a strong interest in discrete mathematics, computer graphics, natural languages, visual arts, and other creative pursuits. 
                Lately, I have also been exploring soldering and electronics.<br> In essence, I love to make things and solve problems. <br>I get excited about elegant solutions,
                whether they are visual, abstract, logical or hands-on. <br><br><br><br><br><br>
                This website serves as a repository for my innovative computer science projects. <br><br> <br><br>
            </p1>
            
        </section>
        <section class="projects">
            <div class="project" id="webgl">
                <img src="projects/webGL/animation/snapshot.png" alt="WebGL Project">
                <h2><a href="projects/webGL/animation/main.html">WebGL</a></h2>
            </div>
            <div class="project" id="opengl">
                <img src="projects/OpenGL/HermiteSpline/hermiteSpline.gif" alt="OpenGL Project">
                <h2><a href="projects/opengl.html">OpenGL</a></h2>
            </div>
            <div class="project" id="vulkan">
                <img src="projects/vulkan.jpg" alt="Vulkan Project">
                <h2><a href="projects/vulkan.html">Vulkan</a></h2>
            </div>
            <div class="project" id="Raytracer">
                <img src="projects/Raytracer/snapshot.png" alt="Raytracer Project">
                <h2><a href="projects/Raytracer.html">Raytracer</a></h2>
            </div>
            <div class="project" id="Arduino Projects">
                <img src="projects/Arduino/LEDs.jpg" alt="Arduino projects">
                <h2><a href="projects/Arduino.html">Arduino projects</a></h2>
            </div>
        </section>
    </main>

    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
             
        in vec4 a_position;
        
        out vec2 v_uv;
        void main() {
            
            v_uv = a_position.xy * 0.5 + 0.5; // normalize to [0,1]
            gl_Position = a_position;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
        precision mediump float;
                
        uniform vec2 u_resolution;
        uniform float u_time;
                
        in vec2 v_uv; 
        out vec4 outColor;
                
        #define S(a,b,t) smoothstep(a,b,t)
        #define ROT -0.785398
        #define ZOOM .25
        #define STAR_SPEED 2.
                
        float random(vec2 st) {
            return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        }
        
        float star(vec2 position, vec2 starPosition, float size, float brightness) {
            float d = length(position - starPosition);
            return smoothstep(size, size - 0.01, d) * brightness;
        }
        
        float N21(vec2 p) {
            p = fract(p * vec2(233.34, 851.73));
            p += dot(p, p + 23.45);
            return fract(p.x * p.y);
        }
        
        float DistLine(vec2 p, vec2 a, vec2 b) {
            vec2 pa = p - a;
            vec2 ba = b - a;
            float t = clamp(dot(pa, ba) / dot(ba, ba), 0., 1.);
            return length(pa - ba * t);
        }
        
        float DrawLine(vec2 p, vec2 a, vec2 b) {
            float d = DistLine(p, a, b);
            float m = S(.0025, .00001, d);
            float d2 = length(a - b);
            m *= S(1., .5, d2) + S(.04, .03, abs(d2 - .75));
            return m;
        }
        
        float ShootingStar(vec2 uv) {
            vec2 gv = fract(uv) - .5;
            vec2 id = floor(uv);
            float h = N21(id);
            float line = DrawLine(gv, vec2(0., h), vec2(.125, h));
            float trail = S(.14, .0, gv.x);
            return line * trail;
        }
        
        void main() {
            vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
            vec2 st = v_uv * u_resolution / max(u_resolution.x, u_resolution.y);
        
            vec3 color = vec3(0.0);
        
            // Normal stars
            int numNormalStars = 1000;
            for (int i = 0; i < numNormalStars; i++) {
                vec2 starPos = vec2(random(vec2(i, 0.0)), random(vec2(i, 1.0)));
                float size = random(vec2(i, 2.0)) * 0.008 + 0.002;
                float brightness = random(vec2(i, 3.0)) * 0.8 + 0.2;
                brightness *= sin(u_time*3.8 + float(i)) * 0.5 + 0.5; // Twinkling effect
                //brightness += 0.5;
                color += vec3(star(st, starPos, size, brightness));
            }
        
            // Shooting stars
            float t = u_time * STAR_SPEED;
            vec2 uv = (v_uv * u_resolution - 0.5 * u_resolution) / u_resolution.y;
            vec2 rv1 = vec2(uv.x - t, uv.y + t);
            rv1.x *= 1.1;
            float r = 3. * ROT;
            float s = sin(r);
            float c = cos(r);
            mat2 rot = mat2(c, -s, s, c);
            rv1 *= rot;
            rv1 *= ZOOM * .9;
            vec2 rv2 = uv + t * 1.2;
            rv2.x *= 1.1;
            r = ROT;
            s = sin(r);
            c = cos(r);
            rot = mat2(c, -s, s, c);
            rv2 *= rot;
            rv2 *= ZOOM * 1.1;
            float star1 = ShootingStar(rv1);
            float star2 = ShootingStar(rv2);
            color += vec3(clamp(star1 + star2, 0., 1.));
        
            outColor = vec4(color, 1.0);
        }

        //#version 300 es
        //precision mediump float;
        //
        //uniform vec2 u_resolution;
        //uniform float u_time;
        //
        //in vec2 v_uv; 
        //out vec4 outColor;
        //
        //float random(vec2 st) {
        //    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
        //}
        //
        //float star(vec2 position, vec2 starPosition, float size, float brightness) {
        //    float d = length(position - starPosition);
        //    return smoothstep(size, size - 0.01, d) * brightness;
        //}
        //
        //vec3 nebula(vec2 st, vec2 clusterPos, float clusterSize) {
        //    float d = length(st - clusterPos);
        //    float intensity = exp(-pow(d / clusterSize, 2.0)); // Gaussian falloff
        //    vec3 color = vec3(0.5 * clusterSize, 0.3 * clusterPos.x, 0.8); // Base color for nebula
        //    return color * intensity;
        //}
        //
        //void main() {
        //// Correct aspect ratio
        //vec2 aspectRatio = vec2(u_resolution.x / u_resolution.y, 1.0);
        //vec2 st = (v_uv - 0.5) * aspectRatio + 0.5; // st texture coord
//
        //vec3 color = vec3(0.0);
//
        //// Nebula effect
        ////int nebulaClusters = 3;
        ////for (int i = 0; i < nebulaClusters; i++) {
        ////    vec2 clusterPos = vec2(random(vec2(i, 0.0)), random(vec2(i, 1.0)));
        ////    float clusterSize = random(vec2(i, 2.0)) * 0.1 * float(i) + 0.05;
        ////    color += nebula(st, clusterPos, clusterSize);
        ////}
//
        //// Shooting stars
//
        //// Number of normal stars 
        //int numNormalStars = 100;
//
        //int shoot = 0;
        //
        //// normal stars
        //for (int i = 0; i < numNormalStars; i++) {
        //    // Create random star position
        //    vec2 starPos = vec2(random(vec2(i, 0.0)), random(vec2(i, 1.0)));
        //    
        //    float size = random(vec2(i, 2.0)) * 0.01 + 0.002;
        //    float brightness = random(vec2(i, 3.0)) * 0.8 + 0.2;
//
        //    if (shoot ==25) {
        //        vec2 shootDirection = vec2(random(vec2(i, 4.0)), random(vec2(i, 5.0))) * 2.0 - 1.0;
        //        shootDirection = normalize(shootDirection);
        //        starPos += shootDirection * mod(u_time, 3.0);
        //        shoot = 0;
        //    }
//
        //    // Slower twinkling effect WORKS
        //    brightness *= sin(u_time + float(i)) * 0.5 + 0.5; // Adjust frequency by scaling u_time
        //    brightness += 0.5 ;
        //    
        //    color += vec3(star(st, starPos, size, brightness));
        //    shoot ++;
        //}
//
       //
//
        //outColor = vec4(color, 1.0);
        //    
        //}
        
    </script>
    <script src="scripts.js"></script>
</body>
</html>



