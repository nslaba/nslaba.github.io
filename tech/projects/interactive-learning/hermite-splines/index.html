<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Hermite Splines | Natalie Slaba</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #0a0a0f;
      --surface: #12121a;
      --accent: #6366f1;
      --accent-dim: rgba(99, 102, 241, 0.3);
      --green: #10b981;
      --orange: #f59e0b;
      --pink: #ec4899;
      --text: #fff;
      --text-muted: rgba(255,255,255,0.5);
      --text-dim: rgba(255,255,255,0.3);
      --font-sans: 'Inter', -apple-system, sans-serif;
      --font-mono: 'JetBrains Mono', monospace;
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      background: var(--bg);
      color: var(--text);
      font-family: var(--font-sans);
      line-height: 1.6;
    }

    /* Navigation */
    .nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      z-index: 100;
      padding: 1.5rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: linear-gradient(to bottom, var(--bg), transparent);
    }

    .nav-left {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .nav-back {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      color: var(--text-muted);
      text-decoration: none;
      transition: color 0.2s;
    }

    .nav-back:hover { color: var(--accent); }
    .nav-sep { color: var(--text-dim); }

    /* Hero Section */
    .hero {
      min-height: 100vh;
      padding: 8rem 2rem 4rem;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    .hero-label {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--accent);
      letter-spacing: 0.2em;
      text-transform: uppercase;
      margin-bottom: 1rem;
    }

    .hero h1 {
      font-size: clamp(2rem, 5vw, 3.5rem);
      font-weight: 500;
      margin-bottom: 1rem;
      text-align: center;
    }

    .hero-subtitle {
      color: var(--text-muted);
      text-align: center;
      max-width: 500px;
      margin-bottom: 3rem;
    }

    /* Main Demo */
    .demo-container {
      width: 100%;
      max-width: 900px;
      aspect-ratio: 16/10;
      min-height: 400px;
      background: var(--surface);
      border-radius: 12px;
      border: 1px solid rgba(255,255,255,0.08);
      position: relative;
      overflow: hidden;
    }

    .demo-canvas {
      width: 100%;
      height: 100%;
      cursor: crosshair;
      display: block;
    }

    .demo-hint {
      position: absolute;
      bottom: 1rem;
      left: 50%;
      transform: translateX(-50%);
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--text-dim);
      pointer-events: none;
    }

    /* Controls */
    .controls {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
      justify-content: center;
      align-items: center;
    }

    .control-btn {
      font-family: var(--font-mono);
      font-size: 0.75rem;
      padding: 0.5rem 1rem;
      background: transparent;
      border: 1px solid rgba(255,255,255,0.2);
      color: var(--text-muted);
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.2s;
    }

    .control-btn:hover {
      border-color: var(--accent);
      color: var(--text);
    }

    .control-btn.active {
      background: var(--accent);
      border-color: var(--accent);
      color: #fff;
    }

    .slider-group {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }

    .slider-label {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .slider {
      width: 120px;
      accent-color: var(--accent);
    }

    .slider-value {
      font-family: var(--font-mono);
      font-size: 0.75rem;
      color: var(--accent);
      min-width: 30px;
    }

    /* Legend */
    .legend {
      display: flex;
      gap: 1.5rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    .legend-dot {
      width: 10px;
      height: 10px;
      border-radius: 50%;
    }

    .legend-line {
      width: 20px;
      height: 3px;
      border-radius: 2px;
    }

    /* Lesson Sections */
    .lesson {
      max-width: 800px;
      margin: 0 auto;
      padding: 4rem 2rem;
    }

    .lesson-section {
      margin-bottom: 5rem;
    }

    .lesson-section h2 {
      font-size: 1.5rem;
      font-weight: 500;
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .lesson-section h2 .step {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--accent);
      letter-spacing: 0.1em;
    }

    .lesson-section p {
      color: var(--text-muted);
      margin-bottom: 1.5rem;
      line-height: 1.8;
    }

    .lesson-section strong {
      color: var(--text);
    }

    /* Math blocks */
    .math-block {
      background: var(--surface);
      border-left: 2px solid var(--accent);
      padding: 1.5rem;
      margin: 1.5rem 0;
      font-family: var(--font-mono);
      font-size: 0.85rem;
      overflow-x: auto;
    }

    .math-block .label {
      color: var(--accent);
      font-size: 0.65rem;
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
    }

    .math-block pre {
      color: var(--text-muted);
      line-height: 1.8;
    }

    /* Intuition boxes */
    .intuition {
      background: rgba(99, 102, 241, 0.08);
      border: 1px solid rgba(99, 102, 241, 0.2);
      border-radius: 8px;
      padding: 1.5rem;
      margin: 2rem 0;
    }

    .intuition-title {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--accent);
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
      text-transform: uppercase;
    }

    .intuition p {
      margin: 0;
      color: var(--text);
    }

    /* Mini demo containers */
    .mini-demo {
      background: var(--surface);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 1.5rem;
      margin: 2rem 0;
    }

    .mini-demo canvas {
      width: 100%;
      max-height: 300px;
      display: block;
    }

    .mini-demo-controls {
      display: flex;
      gap: 1rem;
      margin-top: 1rem;
      flex-wrap: wrap;
      align-items: center;
    }

    /* Comparison container */
    .comparison {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1rem;
      margin: 2rem 0;
    }

    .comparison-panel {
      background: var(--surface);
      border-radius: 8px;
      border: 1px solid rgba(255,255,255,0.08);
      padding: 1rem;
    }

    .comparison-title {
      font-family: var(--font-mono);
      font-size: 0.7rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 0.75rem;
      text-align: center;
    }

    .comparison canvas {
      width: 100%;
      aspect-ratio: 1;
      display: block;
    }

    /* Project links */
    .project-links {
      display: flex;
      gap: 1rem;
      margin-top: 1.5rem;
      flex-wrap: wrap;
    }

    .project-link {
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
      font-family: var(--font-mono);
      font-size: 0.8rem;
      color: var(--text);
      text-decoration: none;
      padding: 0.75rem 1.25rem;
      background: rgba(255,255,255,0.03);
      border: 1px solid rgba(255,255,255,0.1);
      border-radius: 6px;
      transition: all 0.2s;
    }

    .project-link:hover {
      background: var(--accent);
      border-color: var(--accent);
    }

    .project-link svg {
      opacity: 0.7;
    }

    .project-link:hover svg {
      opacity: 1;
    }

    /* Footer */
    footer {
      padding: 3rem 2rem;
      text-align: center;
      border-top: 1px solid rgba(255,255,255,0.05);
    }

    footer a {
      font-family: var(--font-mono);
      font-size: 0.8rem;
      color: var(--text-muted);
      text-decoration: none;
      margin: 0 1rem;
    }

    footer a:hover { color: var(--accent); }

    /* Responsive */
    @media (max-width: 768px) {
      .comparison {
        grid-template-columns: 1fr;
      }
      .controls {
        flex-direction: column;
      }
      .nav { padding: 1rem; }
    }
  </style>
</head>
<body>

  <!-- Navigation -->
  <nav class="nav">
    <div class="nav-left">
      <a href="../../../index.html" class="nav-back">All Projects</a>
      <span class="nav-sep">/</span>
      <a href="../../../../index.html" class="nav-back">Home</a>
    </div>
  </nav>

  <!-- Hero with Main Demo -->
  <section class="hero">
    <span class="hero-label">Interactive Demo</span>
    <h1>Hermite Splines</h1>
    <p class="hero-subtitle">
      Drag the points. Pull the handles. Watch the math come alive.
    </p>

    <div class="demo-container">
      <canvas class="demo-canvas" id="mainDemo"></canvas>
      <span class="demo-hint">drag points to move • drag handles to shape • double-click to add point</span>
    </div>

    <div class="controls">
      <button class="control-btn active" id="toggleTangents">Show Tangents</button>
      <button class="control-btn" id="toggleDerivatives">Show Velocity</button>
      <button class="control-btn" id="toggleAnimation">Animate</button>
      <button class="control-btn" id="resetDemo">Reset</button>
    </div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-dot" style="background: var(--accent)"></div>
        Control Points
      </div>
      <div class="legend-item">
        <div class="legend-dot" style="background: var(--orange)"></div>
        Tangent Handles
      </div>
      <div class="legend-item">
        <div class="legend-line" style="background: var(--green)"></div>
        Velocity Vectors
      </div>
    </div>
  </section>

  <!-- Lessons -->
  <section class="lesson">

    <!-- Section 1: What is a Hermite Spline -->
    <div class="lesson-section">
      <h2><span class="step">01</span> What is a Hermite Spline?</h2>
      <p>
        A Hermite spline is a smooth curve defined by <strong>control points</strong> and
        <strong>tangent vectors</strong>. Unlike Bezier curves (which use intermediate control points),
        Hermite splines let you directly specify the direction and speed at each point.
      </p>
      <p>
        Between any two control points, the curve is a <strong>cubic polynomial</strong> -
        the simplest curve that can match position and direction at both endpoints.
      </p>

      <div class="math-block">
        <div class="label">Hermite Basis Functions</div>
        <pre>
P(t) = h₁(t)·P₀ + h₂(t)·T₀ + h₃(t)·P₁ + h₄(t)·T₁

where:
  h₁(t) = 2t³ - 3t² + 1     (start point influence)
  h₂(t) = t³ - 2t² + t      (start tangent influence)
  h₃(t) = -2t³ + 3t²        (end point influence)
  h₄(t) = t³ - t²           (end tangent influence)

  t ∈ [0, 1]</pre>
      </div>

      <div class="intuition">
        <div class="intuition-title">Intuition</div>
        <p>
          The tangent vectors are like "momentum" - they tell the curve which direction to head
          when leaving a point, and which direction to arrive from. Longer tangents = faster movement
          through that section.
        </p>
      </div>
    </div>

    <!-- Section 2: Derivatives -->
    <div class="lesson-section">
      <h2><span class="step">02</span> Derivatives: The Velocity Along the Curve</h2>
      <p>
        The <strong>derivative</strong> of the spline at any point tells you the velocity -
        both direction and speed. This is crucial for animation: it determines how fast
        an object moves through each part of the curve.
      </p>

      <div class="math-block">
        <div class="label">First Derivative (Velocity)</div>
        <pre>
P'(t) = h₁'(t)·P₀ + h₂'(t)·T₀ + h₃'(t)·P₁ + h₄'(t)·T₁

where:
  h₁'(t) = 6t² - 6t
  h₂'(t) = 3t² - 4t + 1
  h₃'(t) = -6t² + 6t
  h₄'(t) = 3t² - 2t</pre>
      </div>

      <p>
        Notice something important: even if you move through <code>t</code> at a constant rate,
        the <strong>speed along the curve varies</strong>. Tight curves have high velocity magnitude,
        straight sections have lower velocity. This is the problem arc-length parameterization solves.
      </p>

      <div class="mini-demo">
        <canvas id="velocityDemo" height="250"></canvas>
        <div class="mini-demo-controls">
          <span class="slider-label">Scrub t:</span>
          <input type="range" class="slider" id="tScrubber" min="0" max="100" value="50">
          <span class="slider-value" id="tValue">0.50</span>
        </div>
      </div>
    </div>

    <!-- Section 3: The Arc-Length Problem -->
    <div class="lesson-section">
      <h2><span class="step">03</span> The Arc-Length Problem</h2>
      <p>
        Here's the challenge: we want objects to move at <strong>constant speed</strong> along the curve.
        But if we just increment <code>t</code> uniformly, speed varies wildly because the curve
        isn't uniformly distributed in space.
      </p>
      <p>
        The solution is <strong>arc-length parameterization</strong>: instead of asking "where is
        the curve at t=0.5?", we ask "where is the curve at 50% of its total length?"
      </p>
      <p>
        To do this, we need to know the arc length. The formula is:
      </p>

      <div class="math-block">
        <div class="label">Arc Length Integral</div>
        <pre>
s(t) = ∫₀ᵗ |P'(u)| du

     = ∫₀ᵗ √( (dx/du)² + (dy/du)² ) du</pre>
      </div>

      <p>
        <strong>Here's the problem:</strong> for cubic polynomials, this integral has no closed-form solution.
        You're integrating the square root of a quartic polynomial - it produces an
        <strong>elliptic integral</strong>, which can't be expressed with elementary functions.
      </p>

      <div class="intuition">
        <div class="intuition-title">Why No Closed Form?</div>
        <p>
          It's not that we haven't found the formula yet - it's been mathematically proven
          that no formula exists using standard functions (polynomials, trig, exponentials, logs).
          This is a fundamental limitation, not a gap in our knowledge.
        </p>
      </div>
    </div>

    <!-- Section 4: The Approximation -->
    <div class="lesson-section">
      <h2><span class="step">04</span> The Approximation Solution</h2>
      <p>
        Since we can't compute arc length exactly, we <strong>approximate</strong>. The most common
        approach: sample many points along the curve and sum up the straight-line distances between them.
      </p>

      <div class="math-block">
        <div class="label">Piecewise Linear Approximation</div>
        <pre>
s ≈ Σᵢ |P(tᵢ₊₁) - P(tᵢ)|

For n samples:
  t₀ = 0, t₁ = 1/n, t₂ = 2/n, ..., tₙ = 1

Total length ≈ sum of all segment lengths</pre>
      </div>

      <p>
        We build a <strong>lookup table</strong> mapping cumulative arc length to parameter values.
        Then to find "the point at distance d", we binary search the table and interpolate.
      </p>

      <div class="mini-demo">
        <canvas id="samplingDemo" height="280"></canvas>
        <div class="mini-demo-controls">
          <span class="slider-label">Samples:</span>
          <input type="range" class="slider" id="sampleSlider" min="3" max="100" value="10">
          <span class="slider-value" id="sampleValue">10</span>
          <span class="slider-label" style="margin-left: 1rem;">Error:</span>
          <span class="slider-value" id="errorValue">—</span>
        </div>
      </div>

      <p>
        More samples = better accuracy, but also more memory and computation. In practice,
        <strong>50-100 samples per segment</strong> is usually enough for smooth animation.
      </p>
    </div>

    <!-- Section 5: See the Difference -->
    <div class="lesson-section">
      <h2><span class="step">05</span> See the Difference</h2>
      <p>
        Watch the same curve animated two ways: with naive <code>t</code> parameterization (left)
        vs arc-length parameterization (right). Notice how the left object speeds up on curves
        and slows on straight sections.
      </p>

      <div class="comparison">
        <div class="comparison-panel">
          <div class="comparison-title">Naive (uniform t)</div>
          <canvas id="naiveCanvas"></canvas>
        </div>
        <div class="comparison-panel">
          <div class="comparison-title">Arc-Length Parameterized</div>
          <canvas id="arcLengthCanvas"></canvas>
        </div>
      </div>

      <div class="controls" style="justify-content: center;">
        <button class="control-btn active" id="playComparison">Play</button>
        <button class="control-btn" id="resetComparison">Reset</button>
      </div>
    </div>

    <!-- Section 6: The Original Project -->
    <div class="lesson-section">
      <h2><span class="step">06</span> The Original Project</h2>
      <p>
        This interactive explainer is based on a C++/OpenGL project I built for CSC 473.
        The original implements everything above - Hermite splines with Catmull-Rom tangent generation,
        arc-length parameterization via lookup tables, and quaternion-based orientation to keep
        objects aligned with the path.
      </p>

      <div class="mini-demo" style="padding: 0; overflow: hidden;">
        <img src="../../../../projects/OpenGL/HermiteSpline/hermiteSpline.gif"
             alt="Original C++ Hermite Spline project - car following a 3D path"
             style="width: 100%; display: block;">
      </div>

      <div class="project-links">
        <a href="https://github.com/nslaba/CSC-473---HermiteSpline" target="_blank" rel="noopener" class="project-link">
          <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" fill="currentColor" viewBox="0 0 24 24">
            <path d="M12 0c-6.626 0-12 5.373-12 12 0 5.302 3.438 9.8 8.207 11.387.599.111.793-.261.793-.577v-2.234c-3.338.726-4.033-1.416-4.033-1.416-.546-1.387-1.333-1.756-1.333-1.756-1.089-.745.083-.729.083-.729 1.205.084 1.839 1.237 1.839 1.237 1.07 1.834 2.807 1.304 3.492.997.107-.775.418-1.305.762-1.604-2.665-.305-5.467-1.334-5.467-5.931 0-1.311.469-2.381 1.236-3.221-.124-.303-.535-1.524.117-3.176 0 0 1.008-.322 3.301 1.23.957-.266 1.983-.399 3.003-.404 1.02.005 2.047.138 3.006.404 2.291-1.552 3.297-1.23 3.297-1.23.653 1.653.242 2.874.118 3.176.77.84 1.235 1.911 1.235 3.221 0 4.609-2.807 5.624-5.479 5.921.43.372.823 1.102.823 2.222v3.293c0 .319.192.694.801.576 4.765-1.589 8.199-6.086 8.199-11.386 0-6.627-5.373-12-12-12z"/>
          </svg>
          View Source on GitHub
        </a>
      </div>
    </div>

  </section>

  <!-- Footer -->
  <footer>
    <a href="../../../index.html">All Projects</a>
    <a href="../../../../index.html">Home</a>
    <a href="../../../../about.html">About</a>
  </footer>

  <script>
    // =====================================================
    // HERMITE SPLINE INTERACTIVE DEMO
    // =====================================================

    const canvas = document.getElementById('mainDemo');
    const ctx = canvas.getContext('2d');

    // State
    let controlPoints = [];
    let tangents = [];
    let showTangents = true;
    let showDerivatives = false;
    let isAnimating = false;
    let animT = 0;
    let dragging = null;
    let dragType = null; // 'point' or 'tangent'

    // Colors
    const colors = {
      bg: '#12121a',
      curve: '#6366f1',
      point: '#6366f1',
      tangent: '#f59e0b',
      tangentLine: 'rgba(245, 158, 11, 0.4)',
      velocity: '#10b981',
      object: '#ec4899',
      grid: 'rgba(255,255,255,0.03)'
    };

    // Initialize
    function initMainDemo() {
      resizeCanvas();

      // Default points
      const { w, h } = getCanvasSize();

      controlPoints = [
        { x: w * 0.15, y: h * 0.7 },
        { x: w * 0.35, y: h * 0.25 },
        { x: w * 0.65, y: h * 0.75 },
        { x: w * 0.85, y: h * 0.3 }
      ];

      // Auto-generate tangents (Catmull-Rom style)
      generateTangents();
    }

    function generateTangents() {
      tangents = [];
      for (let i = 0; i < controlPoints.length; i++) {
        let tx, ty;
        if (i === 0) {
          tx = (controlPoints[1].x - controlPoints[0].x) * 0.5;
          ty = (controlPoints[1].y - controlPoints[0].y) * 0.5;
        } else if (i === controlPoints.length - 1) {
          tx = (controlPoints[i].x - controlPoints[i-1].x) * 0.5;
          ty = (controlPoints[i].y - controlPoints[i-1].y) * 0.5;
        } else {
          tx = (controlPoints[i+1].x - controlPoints[i-1].x) * 0.25;
          ty = (controlPoints[i+1].y - controlPoints[i-1].y) * 0.25;
        }
        tangents.push({ x: tx, y: ty });
      }
    }

    function resizeCanvas() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const dpr = window.devicePixelRatio || 1;

      // Ensure we have valid dimensions
      const w = rect.width || 800;
      const h = rect.height || 500;

      canvas.width = w * dpr;
      canvas.height = h * dpr;

      // Reset transform before scaling to prevent compound scaling
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.scale(dpr, dpr);
    }

    function getCanvasSize() {
      const dpr = window.devicePixelRatio || 1;
      return {
        w: canvas.width / dpr,
        h: canvas.height / dpr
      };
    }

    // Hermite basis functions
    function h1(t) { return 2*t*t*t - 3*t*t + 1; }
    function h2(t) { return t*t*t - 2*t*t + t; }
    function h3(t) { return -2*t*t*t + 3*t*t; }
    function h4(t) { return t*t*t - t*t; }

    // Derivatives of basis functions
    function h1d(t) { return 6*t*t - 6*t; }
    function h2d(t) { return 3*t*t - 4*t + 1; }
    function h3d(t) { return -6*t*t + 6*t; }
    function h4d(t) { return 3*t*t - 2*t; }

    // Evaluate spline at parameter t for segment i
    function evalSpline(i, t) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const t0 = tangents[i];
      const t1 = tangents[i + 1];

      return {
        x: h1(t) * p0.x + h2(t) * t0.x + h3(t) * p1.x + h4(t) * t1.x,
        y: h1(t) * p0.y + h2(t) * t0.y + h3(t) * p1.y + h4(t) * t1.y
      };
    }

    // Evaluate derivative at parameter t for segment i
    function evalDerivative(i, t) {
      const p0 = controlPoints[i];
      const p1 = controlPoints[i + 1];
      const t0 = tangents[i];
      const t1 = tangents[i + 1];

      return {
        x: h1d(t) * p0.x + h2d(t) * t0.x + h3d(t) * p1.x + h4d(t) * t1.x,
        y: h1d(t) * p0.y + h2d(t) * t0.y + h3d(t) * p1.y + h4d(t) * t1.y
      };
    }

    // Get point along entire spline (t from 0 to 1)
    function getSplinePoint(t) {
      const numSegments = controlPoints.length - 1;
      const segment = Math.min(Math.floor(t * numSegments), numSegments - 1);
      const localT = (t * numSegments) - segment;
      return evalSpline(segment, localT);
    }

    function getSplineDerivative(t) {
      const numSegments = controlPoints.length - 1;
      const segment = Math.min(Math.floor(t * numSegments), numSegments - 1);
      const localT = (t * numSegments) - segment;
      return evalDerivative(segment, localT);
    }

    // Drawing
    function drawGrid() {
      const { w, h } = getCanvasSize();
      const spacing = 30;

      ctx.strokeStyle = colors.grid;
      ctx.lineWidth = 1;

      for (let x = spacing; x < w; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, h);
        ctx.stroke();
      }

      for (let y = spacing; y < h; y += spacing) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(w, y);
        ctx.stroke();
      }
    }

    function drawCurve() {
      ctx.strokeStyle = colors.curve;
      ctx.lineWidth = 3;
      ctx.lineCap = 'round';
      ctx.beginPath();

      const steps = 100;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const p = getSplinePoint(t);
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();
    }

    function drawTangents() {
      if (!showTangents) return;

      for (let i = 0; i < controlPoints.length; i++) {
        const p = controlPoints[i];
        const t = tangents[i];
        const handleX = p.x + t.x;
        const handleY = p.y + t.y;

        // Tangent line
        ctx.strokeStyle = colors.tangentLine;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x - t.x, p.y - t.y);
        ctx.lineTo(handleX, handleY);
        ctx.stroke();

        // Tangent handles
        ctx.fillStyle = colors.tangent;
        ctx.beginPath();
        ctx.arc(handleX, handleY, 6, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.arc(p.x - t.x, p.y - t.y, 6, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawDerivatives() {
      if (!showDerivatives) return;

      const steps = 20;
      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        const p = getSplinePoint(t);
        const d = getSplineDerivative(t);

        const scale = 0.15;
        const mag = Math.sqrt(d.x * d.x + d.y * d.y);
        const nx = d.x / mag * Math.min(mag * scale, 40);
        const ny = d.y / mag * Math.min(mag * scale, 40);

        ctx.strokeStyle = colors.velocity;
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(p.x + nx, p.y + ny);
        ctx.stroke();

        // Arrow head
        const angle = Math.atan2(ny, nx);
        ctx.beginPath();
        ctx.moveTo(p.x + nx, p.y + ny);
        ctx.lineTo(p.x + nx - 6 * Math.cos(angle - 0.4), p.y + ny - 6 * Math.sin(angle - 0.4));
        ctx.moveTo(p.x + nx, p.y + ny);
        ctx.lineTo(p.x + nx - 6 * Math.cos(angle + 0.4), p.y + ny - 6 * Math.sin(angle + 0.4));
        ctx.stroke();
      }
    }

    function drawControlPoints() {
      for (let i = 0; i < controlPoints.length; i++) {
        const p = controlPoints[i];

        ctx.fillStyle = colors.point;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 10, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = colors.bg;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }
    }

    function drawAnimatedObject() {
      if (!isAnimating) return;

      const p = getSplinePoint(animT);
      const d = getSplineDerivative(animT);
      const angle = Math.atan2(d.y, d.x);

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(angle);

      ctx.fillStyle = colors.object;
      ctx.beginPath();
      ctx.moveTo(12, 0);
      ctx.lineTo(-8, -7);
      ctx.lineTo(-8, 7);
      ctx.closePath();
      ctx.fill();

      ctx.restore();
    }

    function draw() {
      const { w, h } = getCanvasSize();

      // Skip drawing if canvas not sized yet
      if (w <= 0 || h <= 0) return;

      ctx.fillStyle = colors.bg;
      ctx.fillRect(0, 0, w, h);

      drawGrid();
      drawCurve();
      drawTangents();
      drawDerivatives();
      drawControlPoints();
      drawAnimatedObject();
    }

    function animate() {
      if (isAnimating) {
        animT += 0.003;
        if (animT > 1) animT = 0;
      }
      draw();
      requestAnimationFrame(animate);
    }

    // Interaction
    function getMousePos(e) {
      const rect = canvas.getBoundingClientRect();
      return {
        x: e.clientX - rect.left,
        y: e.clientY - rect.top
      };
    }

    function findNearestElement(pos, threshold = 20) {
      // Check tangent handles first (they're on top)
      if (showTangents) {
        for (let i = 0; i < controlPoints.length; i++) {
          const p = controlPoints[i];
          const t = tangents[i];

          // Positive handle
          const hx = p.x + t.x;
          const hy = p.y + t.y;
          if (Math.hypot(pos.x - hx, pos.y - hy) < threshold) {
            return { type: 'tangent', index: i, side: 1 };
          }

          // Negative handle
          const nhx = p.x - t.x;
          const nhy = p.y - t.y;
          if (Math.hypot(pos.x - nhx, pos.y - nhy) < threshold) {
            return { type: 'tangent', index: i, side: -1 };
          }
        }
      }

      // Check control points
      for (let i = 0; i < controlPoints.length; i++) {
        const p = controlPoints[i];
        if (Math.hypot(pos.x - p.x, pos.y - p.y) < threshold) {
          return { type: 'point', index: i };
        }
      }

      return null;
    }

    canvas.addEventListener('mousedown', (e) => {
      const pos = getMousePos(e);
      dragging = findNearestElement(pos);
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!dragging) return;
      const pos = getMousePos(e);

      if (dragging.type === 'point') {
        controlPoints[dragging.index] = pos;
      } else if (dragging.type === 'tangent') {
        const p = controlPoints[dragging.index];
        tangents[dragging.index] = {
          x: (pos.x - p.x) * dragging.side,
          y: (pos.y - p.y) * dragging.side
        };
      }
    });

    canvas.addEventListener('mouseup', () => { dragging = null; });
    canvas.addEventListener('mouseleave', () => { dragging = null; });

    canvas.addEventListener('dblclick', (e) => {
      const pos = getMousePos(e);
      controlPoints.push(pos);
      generateTangents();
    });

    // Controls
    document.getElementById('toggleTangents').addEventListener('click', (e) => {
      showTangents = !showTangents;
      e.target.classList.toggle('active', showTangents);
    });

    document.getElementById('toggleDerivatives').addEventListener('click', (e) => {
      showDerivatives = !showDerivatives;
      e.target.classList.toggle('active', showDerivatives);
    });

    document.getElementById('toggleAnimation').addEventListener('click', (e) => {
      isAnimating = !isAnimating;
      e.target.classList.toggle('active', isAnimating);
      e.target.textContent = isAnimating ? 'Stop' : 'Animate';
    });

    document.getElementById('resetDemo').addEventListener('click', () => {
      animT = 0;
      initMainDemo();
    });

    window.addEventListener('resize', () => {
      resizeCanvas();
      initMainDemo();
    });

    // =====================================================
    // VELOCITY DEMO
    // =====================================================

    const velCanvas = document.getElementById('velocityDemo');
    const velCtx = velCanvas.getContext('2d');

    function drawVelocityDemo() {
      const w = velCanvas.width;
      const h = velCanvas.height;
      const t = parseFloat(document.getElementById('tScrubber').value) / 100;

      velCtx.fillStyle = colors.bg;
      velCtx.fillRect(0, 0, w, h);

      // Simple S-curve for demo
      const pts = [
        { x: 50, y: h - 50 },
        { x: w * 0.4, y: 50 },
        { x: w * 0.6, y: h - 50 },
        { x: w - 50, y: 50 }
      ];

      // Draw curve
      velCtx.strokeStyle = colors.curve;
      velCtx.lineWidth = 2;
      velCtx.beginPath();

      for (let i = 0; i <= 100; i++) {
        const u = i / 100;
        const p = evalCatmullRom(pts, u);
        if (i === 0) velCtx.moveTo(p.x, p.y);
        else velCtx.lineTo(p.x, p.y);
      }
      velCtx.stroke();

      // Current point
      const p = evalCatmullRom(pts, t);
      const d = evalCatmullRomDeriv(pts, t);

      // Velocity vector
      const scale = 0.3;
      velCtx.strokeStyle = colors.velocity;
      velCtx.lineWidth = 3;
      velCtx.beginPath();
      velCtx.moveTo(p.x, p.y);
      velCtx.lineTo(p.x + d.x * scale, p.y + d.y * scale);
      velCtx.stroke();

      // Point
      velCtx.fillStyle = colors.object;
      velCtx.beginPath();
      velCtx.arc(p.x, p.y, 8, 0, Math.PI * 2);
      velCtx.fill();

      // Velocity magnitude
      const mag = Math.sqrt(d.x * d.x + d.y * d.y);
      velCtx.fillStyle = 'rgba(255,255,255,0.7)';
      velCtx.font = '12px Inter';
      velCtx.fillText(`|velocity| = ${mag.toFixed(1)}`, 10, 20);
    }

    function evalCatmullRom(pts, t) {
      const n = pts.length - 1;
      const seg = Math.min(Math.floor(t * n), n - 1);
      const lt = (t * n) - seg;

      const p0 = pts[Math.max(seg - 1, 0)];
      const p1 = pts[seg];
      const p2 = pts[Math.min(seg + 1, n)];
      const p3 = pts[Math.min(seg + 2, n)];

      const t2 = lt * lt;
      const t3 = t2 * lt;

      return {
        x: 0.5 * ((2 * p1.x) + (-p0.x + p2.x) * lt + (2*p0.x - 5*p1.x + 4*p2.x - p3.x) * t2 + (-p0.x + 3*p1.x - 3*p2.x + p3.x) * t3),
        y: 0.5 * ((2 * p1.y) + (-p0.y + p2.y) * lt + (2*p0.y - 5*p1.y + 4*p2.y - p3.y) * t2 + (-p0.y + 3*p1.y - 3*p2.y + p3.y) * t3)
      };
    }

    function evalCatmullRomDeriv(pts, t) {
      const n = pts.length - 1;
      const seg = Math.min(Math.floor(t * n), n - 1);
      const lt = (t * n) - seg;

      const p0 = pts[Math.max(seg - 1, 0)];
      const p1 = pts[seg];
      const p2 = pts[Math.min(seg + 1, n)];
      const p3 = pts[Math.min(seg + 2, n)];

      const t2 = lt * lt;

      return {
        x: 0.5 * ((-p0.x + p2.x) + 2*(2*p0.x - 5*p1.x + 4*p2.x - p3.x) * lt + 3*(-p0.x + 3*p1.x - 3*p2.x + p3.x) * t2) * n,
        y: 0.5 * ((-p0.y + p2.y) + 2*(2*p0.y - 5*p1.y + 4*p2.y - p3.y) * lt + 3*(-p0.y + 3*p1.y - 3*p2.y + p3.y) * t2) * n
      };
    }

    document.getElementById('tScrubber').addEventListener('input', (e) => {
      document.getElementById('tValue').textContent = (e.target.value / 100).toFixed(2);
      drawVelocityDemo();
    });

    // =====================================================
    // SAMPLING DEMO
    // =====================================================

    const sampCanvas = document.getElementById('samplingDemo');
    const sampCtx = sampCanvas.getContext('2d');

    function drawSamplingDemo() {
      const w = sampCanvas.width;
      const h = sampCanvas.height;
      const numSamples = parseInt(document.getElementById('sampleSlider').value);

      sampCtx.fillStyle = colors.bg;
      sampCtx.fillRect(0, 0, w, h);

      // Curve points
      const pts = [
        { x: 40, y: h - 40 },
        { x: w * 0.3, y: 40 },
        { x: w * 0.7, y: h - 40 },
        { x: w - 40, y: 40 }
      ];

      // Draw actual curve
      sampCtx.strokeStyle = 'rgba(99, 102, 241, 0.3)';
      sampCtx.lineWidth = 8;
      sampCtx.lineCap = 'round';
      sampCtx.beginPath();
      for (let i = 0; i <= 200; i++) {
        const t = i / 200;
        const p = evalCatmullRom(pts, t);
        if (i === 0) sampCtx.moveTo(p.x, p.y);
        else sampCtx.lineTo(p.x, p.y);
      }
      sampCtx.stroke();

      // Draw sample segments
      sampCtx.strokeStyle = colors.orange;
      sampCtx.lineWidth = 2;
      sampCtx.beginPath();

      let approxLength = 0;
      let prevP = evalCatmullRom(pts, 0);

      for (let i = 0; i <= numSamples; i++) {
        const t = i / numSamples;
        const p = evalCatmullRom(pts, t);

        if (i === 0) {
          sampCtx.moveTo(p.x, p.y);
        } else {
          sampCtx.lineTo(p.x, p.y);
          approxLength += Math.hypot(p.x - prevP.x, p.y - prevP.y);
        }

        // Draw sample points
        sampCtx.fillStyle = colors.orange;
        sampCtx.fillRect(p.x - 3, p.y - 3, 6, 6);

        prevP = p;
      }
      sampCtx.stroke();

      // Calculate "true" length (using many samples)
      let trueLength = 0;
      prevP = evalCatmullRom(pts, 0);
      for (let i = 1; i <= 1000; i++) {
        const p = evalCatmullRom(pts, i / 1000);
        trueLength += Math.hypot(p.x - prevP.x, p.y - prevP.y);
        prevP = p;
      }

      const error = Math.abs(trueLength - approxLength) / trueLength * 100;
      document.getElementById('errorValue').textContent = error.toFixed(2) + '%';

      // Labels
      sampCtx.fillStyle = 'rgba(255,255,255,0.5)';
      sampCtx.font = '11px Inter';
      sampCtx.fillText(`Approx: ${approxLength.toFixed(1)}px`, 10, 20);
      sampCtx.fillText(`Actual: ~${trueLength.toFixed(1)}px`, 10, 35);
    }

    document.getElementById('sampleSlider').addEventListener('input', (e) => {
      document.getElementById('sampleValue').textContent = e.target.value;
      drawSamplingDemo();
    });

    // =====================================================
    // COMPARISON DEMO
    // =====================================================

    const naiveCanvas = document.getElementById('naiveCanvas');
    const naiveCtx = naiveCanvas.getContext('2d');
    const arcCanvas = document.getElementById('arcLengthCanvas');
    const arcCtx = arcCanvas.getContext('2d');

    let compT = 0;
    let compPlaying = true;
    let arcLengthTable = [];

    const compPts = [
      { x: 30, y: 170 },
      { x: 80, y: 30 },
      { x: 170, y: 170 },
      { x: 220, y: 30 }
    ];

    function buildArcLengthTable() {
      arcLengthTable = [{ t: 0, s: 0 }];
      let totalS = 0;
      let prevP = evalCatmullRom(compPts, 0);

      for (let i = 1; i <= 200; i++) {
        const t = i / 200;
        const p = evalCatmullRom(compPts, t);
        totalS += Math.hypot(p.x - prevP.x, p.y - prevP.y);
        arcLengthTable.push({ t, s: totalS });
        prevP = p;
      }

      // Normalize
      for (let entry of arcLengthTable) {
        entry.s /= totalS;
      }
    }

    function sToT(s) {
      // Binary search
      let lo = 0, hi = arcLengthTable.length - 1;
      while (lo < hi - 1) {
        const mid = Math.floor((lo + hi) / 2);
        if (arcLengthTable[mid].s < s) lo = mid;
        else hi = mid;
      }

      const entry0 = arcLengthTable[lo];
      const entry1 = arcLengthTable[hi];
      const frac = (s - entry0.s) / (entry1.s - entry0.s + 0.0001);
      return entry0.t + frac * (entry1.t - entry0.t);
    }

    function drawComparisonCanvas(ctx, pts, t, useArcLength) {
      const w = ctx.canvas.width;
      const h = ctx.canvas.height;

      ctx.fillStyle = colors.bg;
      ctx.fillRect(0, 0, w, h);

      // Curve
      ctx.strokeStyle = colors.curve;
      ctx.lineWidth = 2;
      ctx.beginPath();
      for (let i = 0; i <= 100; i++) {
        const u = i / 100;
        const p = evalCatmullRom(pts, u);
        if (i === 0) ctx.moveTo(p.x, p.y);
        else ctx.lineTo(p.x, p.y);
      }
      ctx.stroke();

      // Object
      const actualT = useArcLength ? sToT(t) : t;
      const p = evalCatmullRom(pts, actualT);
      const d = evalCatmullRomDeriv(pts, actualT);
      const angle = Math.atan2(d.y, d.x);

      ctx.save();
      ctx.translate(p.x, p.y);
      ctx.rotate(angle);
      ctx.fillStyle = colors.object;
      ctx.beginPath();
      ctx.moveTo(10, 0);
      ctx.lineTo(-6, -5);
      ctx.lineTo(-6, 5);
      ctx.closePath();
      ctx.fill();
      ctx.restore();
    }

    function resizeComparisonCanvases() {
      [naiveCanvas, arcCanvas].forEach(c => {
        const rect = c.parentElement.getBoundingClientRect();
        c.width = rect.width - 32;
        c.height = rect.width - 32;
      });

      // Rescale points for canvas size
      const scale = naiveCanvas.width / 250;
      compPts[0] = { x: 30 * scale, y: 170 * scale };
      compPts[1] = { x: 80 * scale, y: 30 * scale };
      compPts[2] = { x: 170 * scale, y: 170 * scale };
      compPts[3] = { x: 220 * scale, y: 30 * scale };

      buildArcLengthTable();
    }

    function animateComparison() {
      if (compPlaying) {
        compT += 0.005;
        if (compT > 1) compT = 0;
      }

      drawComparisonCanvas(naiveCtx, compPts, compT, false);
      drawComparisonCanvas(arcCtx, compPts, compT, true);

      requestAnimationFrame(animateComparison);
    }

    document.getElementById('playComparison').addEventListener('click', (e) => {
      compPlaying = !compPlaying;
      e.target.textContent = compPlaying ? 'Pause' : 'Play';
      e.target.classList.toggle('active', compPlaying);
    });

    document.getElementById('resetComparison').addEventListener('click', () => {
      compT = 0;
    });

    // =====================================================
    // INIT
    // =====================================================

    function resizeAllCanvases() {
      // Velocity demo
      velCanvas.width = velCanvas.parentElement.clientWidth - 48;
      velCanvas.height = 250;
      drawVelocityDemo();

      // Sampling demo
      sampCanvas.width = sampCanvas.parentElement.clientWidth - 48;
      sampCanvas.height = 280;
      drawSamplingDemo();

      // Comparison
      resizeComparisonCanvases();
    }

    window.addEventListener('load', () => {
      initMainDemo();
      animate();

      resizeAllCanvases();
      animateComparison();
    });

    window.addEventListener('resize', resizeAllCanvases);
  </script>

</body>
</html>
