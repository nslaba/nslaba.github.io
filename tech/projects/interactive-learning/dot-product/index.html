<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Orbital Escape: A Dot Product Journey | Natalie Slaba</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --color-bg: #0f0f1a;
            --color-surface: #1a1a2e;
            --color-primary: #6366f1;
            --color-secondary: #818cf8;
            --color-accent: #a5b4fc;
            --color-success: #10b981;
            --color-white: #fafafa;
            --color-gray-400: #a3a3a3;
            --color-gray-600: #525252;
            --font-sans: 'Inter', -apple-system, sans-serif;
            --font-mono: 'JetBrains Mono', monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg);
            color: var(--color-white);
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        .ui-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        /* Navigation */
        .game-nav {
            position: absolute;
            top: 1.5rem;
            left: 1.5rem;
            pointer-events: auto;
        }

        .back-link {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--color-gray-400);
            text-decoration: none;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: color 0.2s;
        }

        .back-link:hover {
            color: var(--color-primary);
        }

        .level-title {
            position: absolute;
            top: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--font-mono);
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            color: var(--color-primary);
        }

        .objective {
            position: absolute;
            top: 3.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-size: 1rem;
            color: var(--color-gray-400);
            text-align: center;
            max-width: 500px;
            padding: 0 1rem;
            line-height: 1.6;
        }

        .fuel-bar {
            position: absolute;
            top: 1.5rem;
            right: 1.5rem;
            width: 180px;
        }

        .fuel-label {
            font-family: var(--font-mono);
            font-size: 0.7rem;
            color: var(--color-gray-400);
            margin-bottom: 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .fuel-container {
            width: 100%;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
        }

        .fuel-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--color-success), #34d399);
            transition: width 0.3s ease;
            border-radius: 3px;
        }

        .instruction {
            position: absolute;
            bottom: 1.5rem;
            left: 50%;
            transform: translateX(-50%);
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--color-gray-400);
            background: rgba(255, 255, 255, 0.03);
            padding: 0.75rem 1.5rem;
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.05);
        }

        .success-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: var(--color-surface);
            padding: 2.5rem;
            border-radius: 8px;
            text-align: center;
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.34, 1.56, 0.64, 1);
            border: 1px solid rgba(99, 102, 241, 0.3);
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5), 0 0 40px rgba(99, 102, 241, 0.2);
            pointer-events: auto;
            max-width: 550px;
            visibility: hidden;
        }

        .success-modal.show {
            transform: translate(-50%, -50%) scale(1);
            opacity: 1;
            visibility: visible;
        }

        .success-modal h2 {
            font-family: var(--font-mono);
            font-size: 0.75rem;
            letter-spacing: 0.15em;
            text-transform: uppercase;
            color: var(--color-success);
            margin-bottom: 0.75rem;
        }

        .success-modal p {
            font-size: 1rem;
            color: var(--color-gray-400);
            margin-bottom: 1.5rem;
            line-height: 1.7;
        }

        .success-modal strong {
            color: var(--color-white);
        }

        .next-btn {
            font-family: var(--font-mono);
            font-size: 0.8rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            background: transparent;
            color: var(--color-primary);
            border: 1px solid var(--color-primary);
            padding: 0.75rem 2rem;
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .next-btn:hover {
            background: var(--color-primary);
            color: var(--color-white);
        }

        .formula {
            font-family: var(--font-mono);
            font-size: 1.5rem;
            margin: 1.5rem 0;
            color: var(--color-accent);
        }

        .reset-btn {
            position: absolute;
            bottom: 1.5rem;
            left: 1.5rem;
            font-family: var(--font-mono);
            font-size: 0.75rem;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: var(--color-gray-400);
            padding: 0.5rem 1rem;
            border-radius: 4px;
            cursor: pointer;
            pointer-events: auto;
            transition: all 0.2s;
        }

        .reset-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: var(--color-white);
        }

        .dot-display {
            position: absolute;
            bottom: 1.5rem;
            right: 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.08);
            border-radius: 8px;
            padding: 0.75rem 1.25rem;
            text-align: center;
            pointer-events: none;
        }

        .dot-label {
            display: block;
            font-family: var(--font-mono);
            font-size: 0.65rem;
            color: var(--color-gray-400);
            text-transform: uppercase;
            letter-spacing: 0.1em;
            margin-bottom: 0.25rem;
        }

        .dot-value {
            font-family: var(--font-mono);
            font-size: 1.5rem;
            font-weight: 600;
            color: var(--color-gray-400);
            transition: color 0.2s;
        }

        .dot-value.positive { color: var(--color-success); }
        .dot-value.negative { color: #ef4444; }
        .dot-value.neutral { color: var(--color-gray-400); }

        @media (max-width: 768px) {
            .level-title { font-size: 0.65rem; }
            .objective { font-size: 0.9rem; top: 3rem; }
            .fuel-bar { width: 140px; }
            .game-nav { display: none; }

            .success-modal {
                width: calc(100vw - 2rem);
                max-width: none;
                padding: 1.5rem;
                max-height: 85vh;
                overflow-y: auto;
            }
            .success-modal p {
                font-size: 0.85rem;
            }
            .formula {
                font-size: 1.1rem;
                margin: 1rem 0;
            }
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div class="ui-overlay">
        <nav class="game-nav">
            <a href="../../../index.html" class="back-link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M10 19l-7-7m0 0l7-7m-7 7h18" />
                </svg>
                Back to Projects
            </a>
        </nav>

        <button class="reset-btn" onclick="resetLevel()">Reset</button>

        <div class="level-title" id="levelTitle">Level 1: Get to Orbit</div>
        <div class="objective" id="objective">Your satellite is stuck! Click to fire thrusts and get it moving fast enough to complete one full orbit.</div>

        <div class="fuel-bar">
            <div class="fuel-label">Fuel: <span id="fuelText">100%</span></div>
            <div class="fuel-container">
                <div class="fuel-fill" id="fuelFill" style="width: 100%"></div>
            </div>
        </div>

        <div class="instruction" id="instruction">Click anywhere to thrust in that direction</div>

        <div class="dot-display" id="dotDisplay">
            <span class="dot-label">alignment</span>
            <span class="dot-value" id="dotValue">—</span>
        </div>

        <div class="success-modal" id="successModal">
            <h2 id="successTitle">Level Complete</h2>
            <p id="successMessage"></p>
            <button class="next-btn" onclick="nextLevel()">Continue</button>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let currentLevel = 1;
        let planet = { x: 0, y: 0, radius: 40 };
        let satellite = { angle: 0, distance: 250, velocity: 0, x: 0, y: 0 };
        let fuel = 100;
        let maxFuel = 100;
        let trail = [];
        let totalAngleTraveled = 0;
        let targetReached = false;
        let showProjection = false;
        let projectionAlpha = 0;
        let scaleFactor = 1;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            planet.x = canvas.width / 2;
            planet.y = canvas.height / 2;
            // Scale everything relative to the smaller viewport dimension
            const minDim = Math.min(canvas.width, canvas.height);
            scaleFactor = minDim / 900; // 900 is the reference size
            planet.radius = Math.max(20, 40 * scaleFactor);
            satellite.distance = Math.max(100, 250 * scaleFactor);
        }

        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const levels = {
            1: {
                title: "Level 1: Get to Orbit",
                objective: "Your satellite is stuck! Click in the direction of movement (along the purple arrow) to speed up.",
                fuel: 200,
                targetSpeed: 0.008,
                successMessage: "You discovered that thrusting <strong>along the direction of movement</strong> speeds things up efficiently.",
                instruction: "Click ahead of the satellite to thrust forward"
            },
            2: {
                title: "Level 2: Reach the Target",
                objective: "Accelerate your satellite to reach the outer green ring. Keep thrusting in the direction you're moving!",
                fuel: 250,
                targetDistanceFactor: 1.52,
                successMessage: "You learned that <strong>consistent alignment</strong> with velocity builds momentum.",
                instruction: "Click to thrust - stay aligned with velocity"
            },
            3: {
                title: "Level 3: The Landing",
                objective: "Now slow down! Thrust OPPOSITE to your movement to brake (get below 30% speed).",
                fuel: 200,
                targetSpeed: 0.006,
                reverse: true,
                successMessage: "You found that thrusting <strong>opposite to velocity</strong> slows you down.",
                instruction: "Click behind the satellite to slow down"
            },
            4: {
                title: "The Truth Revealed",
                objective: "",
                isReveal: true
            }
        };

        function drawArrow(x1, y1, x2, y2, color, width = 2) {
            const headlen = 10;
            const dx = x2 - x1;
            const dy = y2 - y1;
            const angle = Math.atan2(dy, dx);
            const len = Math.sqrt(dx * dx + dy * dy);
            if (len < 1) return;

            ctx.strokeStyle = color;
            ctx.fillStyle = color;
            ctx.lineWidth = width;
            ctx.lineCap = 'round';

            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(x2, y2);
            ctx.lineTo(x2 - headlen * Math.cos(angle - Math.PI / 6), y2 - headlen * Math.sin(angle - Math.PI / 6));
            ctx.lineTo(x2 - headlen * Math.cos(angle + Math.PI / 6), y2 - headlen * Math.sin(angle + Math.PI / 6));
            ctx.closePath();
            ctx.fill();
        }

        function updateUI() {
            const fuelPercent = (fuel / maxFuel * 100).toFixed(0);
            document.getElementById('fuelText').textContent = fuelPercent + '%';
            document.getElementById('fuelFill').style.width = fuelPercent + '%';
        }

        function loadLevel(level) {
            const config = levels[level];

            if (config.isReveal) {
                showReveal();
                return;
            }

            document.getElementById('levelTitle').textContent = config.title;
            document.getElementById('objective').textContent = config.objective;
            document.getElementById('instruction').textContent = config.instruction;

            satellite.angle = 0;
            satellite.velocity = level === 3 ? 0.02 : 0.002; // Level 3 starts fast, others start with slight movement
            satellite.distance = Math.max(100, 250 * scaleFactor);
            fuel = config.fuel;
            maxFuel = config.fuel;
            trail = [];
            totalAngleTraveled = 0;
            targetReached = false;
            showProjection = false;
            projectionAlpha = 0;

            updateUI();
        }

        function checkWinCondition() {
            const config = levels[currentLevel];

            if (currentLevel === 1) {
                // Complete one full orbit (2π radians) while still moving
                if (totalAngleTraveled >= Math.PI * 2 && Math.abs(satellite.velocity) > 0.005) {
                    showSuccess();
                }
            } else if (currentLevel === 2) {
                if (satellite.distance >= (config.targetDistanceFactor || 1.52) * 250 * scaleFactor) {
                    showSuccess();
                }
            } else if (currentLevel === 3) {
                if (Math.abs(satellite.velocity) < config.targetSpeed && Math.abs(satellite.velocity) > 0) {
                    showSuccess();
                }
            }
        }

        function showSuccess() {
            if (targetReached) return;
            targetReached = true;

            const config = levels[currentLevel];
            document.getElementById('successTitle').textContent = "Level Complete";
            document.getElementById('successMessage').innerHTML = config.successMessage;
            document.getElementById('successModal').classList.add('show');

            showProjection = true;
        }

        function showReveal() {
            document.getElementById('levelTitle').textContent = "The Truth Revealed";
            document.getElementById('objective').textContent = "";
            document.getElementById('instruction').style.display = 'none';
            document.querySelector('.fuel-bar').style.display = 'none';
            document.querySelector('.reset-btn').style.display = 'none';
            document.getElementById('dotDisplay').style.display = 'none';

            setTimeout(() => {
                const modal = document.getElementById('successModal');
                document.getElementById('successTitle').textContent = "You Just Learned The Dot Product";
                document.getElementById('successMessage').innerHTML = `
                    <div class="formula">a · b = |a| |b| cos(θ)</div>
                    <p style="margin: 1rem 0; text-align: left;">Every time you aligned your thrust with velocity, you were <strong>maximizing the dot product</strong>.</p>
                    <p style="text-align: left; margin-bottom: 1rem;">The dot product measures <strong>alignment</strong> between two vectors:</p>
                    <p style="text-align: left; font-family: var(--font-mono); font-size: 0.85rem; line-height: 2;">
                        Aligned (0°) → cos(0°) = 1 → Maximum effect<br>
                        Perpendicular (90°) → cos(90°) = 0 → No effect<br>
                        Opposite (180°) → cos(180°) = -1 → Reverse effect
                    </p>
                    <div class="formula" style="font-size: 1.2rem; margin-top: 1.5rem;">= a<sub>x</sub>b<sub>x</sub> + a<sub>y</sub>b<sub>y</sub></div>
                `;
                document.querySelector('.next-btn').textContent = "Play Again";
                document.querySelector('.next-btn').onclick = () => {
                    currentLevel = 1;
                    document.getElementById('successModal').classList.remove('show');
                    document.querySelector('.instruction').style.display = 'block';
                    document.querySelector('.fuel-bar').style.display = 'block';
                    document.querySelector('.reset-btn').style.display = 'block';
                    document.getElementById('dotDisplay').style.display = 'block';
                    document.getElementById('dotValue').textContent = '—';
                    loadLevel(1);
                };
                modal.classList.add('show');
            }, 500);

            showProjection = true;
            projectionAlpha = 1;
        }

        function nextLevel() {
            document.getElementById('successModal').classList.remove('show');
            currentLevel++;
            loadLevel(currentLevel);
        }

        function resetLevel() {
            loadLevel(currentLevel);
        }

        function handleThrust(clientX, clientY) {
            if (targetReached || levels[currentLevel].isReveal) return;
            if (fuel <= 0) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = clientX - rect.left;
            const mouseY = clientY - rect.top;

            const thrustAngle = Math.atan2(mouseY - satellite.y, mouseX - satellite.x);
            const velAngle = satellite.angle + Math.PI / 2;

            const thrustX = Math.cos(thrustAngle);
            const thrustY = Math.sin(thrustAngle);
            const velX = Math.cos(velAngle);
            const velY = Math.sin(velAngle);

            const alignment = velX * thrustX + velY * thrustY;

            satellite.velocity += alignment * 0.004;
            fuel -= 8;
            if (fuel < 0) fuel = 0;

            showAlignmentFeedback(alignment, clientX, clientY);
            updateUI();
        }

        canvas.addEventListener('click', (e) => handleThrust(e.clientX, e.clientY));

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            const touch = e.touches[0];
            handleThrust(touch.clientX, touch.clientY);
        }, { passive: false });

        // Visual feedback for alignment
        let feedbackParticles = [];

        function showAlignmentFeedback(alignment, x, y) {
            const color = alignment > 0.5 ? '#10b981' : alignment > 0 ? '#fbbf24' : '#ef4444';
            const text = alignment > 0.7 ? 'Great!' : alignment > 0.3 ? 'Good' : alignment > 0 ? 'Weak' : 'Wrong way!';
            feedbackParticles.push({
                x, y,
                text,
                color,
                alpha: 1,
                vy: -2
            });

            // Update dot product display
            const dotValue = document.getElementById('dotValue');
            dotValue.textContent = alignment.toFixed(2);
            dotValue.className = 'dot-value ' + (alignment > 0.3 ? 'positive' : alignment < -0.3 ? 'negative' : 'neutral');
        }

        function animate() {
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Subtle grid
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.03)';
            ctx.lineWidth = 1;
            const gridSize = 50;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            satellite.x = planet.x + Math.cos(satellite.angle) * satellite.distance;
            satellite.y = planet.y + Math.sin(satellite.angle) * satellite.distance;
            satellite.velocity *= 0.9995; // Minimal decay - focus on learning alignment
            totalAngleTraveled += Math.abs(satellite.velocity);
            satellite.angle += satellite.velocity;

            if (currentLevel === 2 && !targetReached) {
                const speed = Math.abs(satellite.velocity);
                if (speed > 0.01) {
                    satellite.distance += speed * 2;
                }
            }

            trail.push({ x: satellite.x, y: satellite.y });
            if (trail.length > 100) trail.shift();

            // Target ring for level 2
            if (currentLevel === 2) {
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.3)';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(planet.x, planet.y, 400 * scaleFactor, 0, Math.PI * 2);
                ctx.stroke();
            }

            // Orbit reference
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.15)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, 250 * scaleFactor, 0, Math.PI * 2);
            ctx.stroke();

            // Trail
            ctx.strokeStyle = 'rgba(16, 185, 129, 0.4)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            trail.forEach((p, i) => {
                if (i === 0) ctx.moveTo(p.x, p.y);
                else ctx.lineTo(p.x, p.y);
            });
            ctx.stroke();

            // Planet
            const gradient = ctx.createRadialGradient(planet.x, planet.y, 0, planet.x, planet.y, planet.radius);
            gradient.addColorStop(0, '#fbbf24');
            gradient.addColorStop(1, '#d97706');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(planet.x, planet.y, planet.radius, 0, Math.PI * 2);
            ctx.fill();

            // Satellite
            ctx.fillStyle = '#10b981';
            ctx.beginPath();
            ctx.arc(satellite.x, satellite.y, Math.max(5, 8 * scaleFactor), 0, Math.PI * 2);
            ctx.fill();

            // Velocity vector
            const velAngle = satellite.angle + Math.PI / 2;
            const velX = Math.cos(velAngle);
            const velY = Math.sin(velAngle);
            const arrowLen = 50 * scaleFactor;
            drawArrow(satellite.x, satellite.y,
                satellite.x + velX * arrowLen, satellite.y + velY * arrowLen, '#6366f1', 2);

            // Projection visualization after success
            if (showProjection && !levels[currentLevel].isReveal) {
                projectionAlpha = Math.min(1, projectionAlpha + 0.02);

                const projLen = 70 * scaleFactor;
                const exampleAngle = velAngle + 0.3;
                const thrustX = Math.cos(exampleAngle);
                const thrustY = Math.sin(exampleAngle);
                const alignment = velX * thrustX + velY * thrustY;
                const projMag = alignment * projLen;
                const projEndX = satellite.x + velX * projMag;
                const projEndY = satellite.y + velY * projMag;

                ctx.globalAlpha = projectionAlpha;

                drawArrow(satellite.x, satellite.y,
                    satellite.x + thrustX * projLen, satellite.y + thrustY * projLen, '#ec4899', 2);

                ctx.strokeStyle = `rgba(251, 191, 36, ${0.4 * projectionAlpha})`;
                ctx.lineWidth = 1;
                ctx.setLineDash([4, 4]);
                ctx.beginPath();
                ctx.moveTo(satellite.x + thrustX * projLen, satellite.y + thrustY * projLen);
                ctx.lineTo(projEndX, projEndY);
                ctx.stroke();
                ctx.setLineDash([]);

                if (Math.abs(projMag) > 5) {
                    drawArrow(satellite.x, satellite.y, projEndX, projEndY, '#fbbf24', 3);
                }

                ctx.globalAlpha = 1;
            }

            // Labels
            const labelOffset = (arrowLen + 5);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '12px Inter, sans-serif';
            ctx.fillText('velocity', satellite.x + velX * labelOffset + 5, satellite.y + velY * labelOffset);

            // Speed indicator
            const speed = Math.abs(satellite.velocity);
            const speedPercent = (speed / 0.02 * 100).toFixed(0);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '600 14px Inter, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(`${speedPercent}%`, satellite.x, satellite.y - 22);
            ctx.textAlign = 'left';

            // Draw alignment feedback particles
            feedbackParticles = feedbackParticles.filter(p => {
                p.y += p.vy;
                p.alpha -= 0.025;
                if (p.alpha <= 0) return false;

                ctx.globalAlpha = p.alpha;
                ctx.fillStyle = p.color;
                ctx.font = 'bold 14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText(p.text, p.x, p.y);
                ctx.textAlign = 'left';
                ctx.globalAlpha = 1;
                return true;
            });

            // Hint: show ideal click zone (faint arc in direction of velocity)
            if (!targetReached && fuel > 0) {
                const hintAngle = velAngle;
                const hintDist = 80 * scaleFactor;
                ctx.strokeStyle = 'rgba(16, 185, 129, 0.15)';
                ctx.lineWidth = Math.max(10, 20 * scaleFactor);
                ctx.lineCap = 'round';
                ctx.beginPath();
                if (currentLevel === 3) {
                    ctx.arc(satellite.x, satellite.y, hintDist, hintAngle + Math.PI - 0.5, hintAngle + Math.PI + 0.5);
                } else {
                    ctx.arc(satellite.x, satellite.y, hintDist, hintAngle - 0.5, hintAngle + 0.5);
                }
                ctx.stroke();
            }

            checkWinCondition();
            requestAnimationFrame(animate);
        }

        window.addEventListener('load', () => {
            loadLevel(1);
            animate();
        });
    </script>
</body>
</html>
