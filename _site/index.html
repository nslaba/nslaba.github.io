    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Natalie Slaba, Computer Scientist + Artist</title>
        <link rel="stylesheet" href="style.css">
        <script defer src="scripts.js"></script>
        <link href="https://fonts.googleapis.com/css2?family=Pacifico&display=swap" rel="stylesheet">
    </head>
    <body>
        <canvas id="glcanvas"></canvas>
        
        <header>
            <h1><a href="about.html">Natalie Slaba</a></h1>
        </header>
        <main>
            <section class="description">
                <br><br><br><br><br><br><br><br><br>
                <p>Programmer Artist</p>
                <br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
                <!-- <p>Welcome to my personal website for creative computer science projects. <br><br><br><br><br><br>
                    I hold a Bachelor of Science in Computer Science and Visual Arts from the University of Victoria (spring 2024).<br><br>
                    I have a strong interest in discrete mathematics, computer graphics, natural languages, visual arts, and other creative pursuits. 
                    Lately, I have also been exploring soldering and electronics.<br> In essence, I love to make things and solve problems. <br>I get excited about elegant solutions,
                    whether they are visual, abstract, logical or hands-on. <br><br><br><br><br><br>
                    This website serves as a repository for my innovative computer science projects. <br><br> <br><br>
                </p> -->
            </section>
    
          
            <section class="projects">
                <h2>Projects</h2>
                <div class="project-slider-container">
                    <button class="arrow arrow-left">&lt;</button>
                    <div class="project-slider">
                        <div class="project" id="webgl">
                            <img src="projects/webGL/animation/snapshot.png" alt="WebGL Project">
                            <h3><a href="projects/webGL/animation/main.html">WebGL</a></h3>
                        </div>
                        <div class="project" id="opengl">
                            <img src="projects/OpenGL/HermiteSpline/hermiteSpline.gif" alt="OpenGL Project">
                            <h3><a href="projects/OpenGL/opengl.html">OpenGL</a></h3>
                        </div>
                        <div class="project" id="vulkan">
                            <img src="projects/Vulkan/vulkan_texture.gif" alt="Vulkan Project">
                            <h3><a href="projects/Vulkan/vulkan.html">Vulkan</a></h3>
                        </div>
                        <div class="project" id="raytracer">
                            <img src="projects/Raytracer/snapshot.png" alt="Raytracer Project">
                            <h3><a href="projects/Raytracer/Raytracer.html">Raytracer</a></h3>
                        </div>
                        <div class="project" id="arduino-projects">
                            <img src="projects/Arduino/LEDs.jpg" alt="Arduino projects">
                            <h3><a href="projects/Arduino/Arduino.html">Arduino projects</a></h3>
                        </div>
                    </div>
                    <button class="arrow arrow-right">&gt;</button>
                </div>
            </section>
            
            
    
            <hr>
    
            <section id="about" class="about">
                <h2>About Nat</h2>
                <div class="about-sections">
                    <!-- <div class="about-section">
                        <h3>Natural Languages</h3>
                        <p>Due to my diverse upbringing and curiosity, I've integrated into various cultures throughout 
                            my life, 
                            learning six languages to fluency. I use four of these languages daily. 
                            Learning languages has been a fascinating and character-building experience.<br><br>

                            On average, it has taken me 1 to 4 months to fully communicate in a new language. 
                            I learned Spanish within a month and have spoken it for the last nine years. 
                            The same year I learned Spanish in Colombia, I traveled to Austria and learned German in four months 
                            from scratch, passing a B2 level exam. Interestingly, I studied German grammar using a course in Spanish, 
                            which I had only just learned a few months prior. I also learned Levantine Arabic during my integration in 
                            the West Bank, where I stayed during the COVID-19 pandemic.<br><br>
                            
                            Languages are beautiful for many reasons. They shift your perspective on sounds and foster deep 
                            appreciation for people, as all native speakers become your teachers. However, as language learning is 
                            primarily human-based, it forces you to open your eyes to societal issues such as classism, discrimination, 
                            and injustices. While I can navigate the complexities of grammar and pronunciation, the human aspect remains 
                            challenging. This is why I prefer to keep my intellectual pursuits in the simpler realm of computers for now.</p>
                        
                    </div> -->
                    <div class="about-section">
                        <h3>Visual Arts</h3>
                        <p>Similar to mathematics, what I greatly enjoy about visual arts is the abstraction. It's a beautiful way to connect 
                            ideas, shift perspectives, and deepen your understanding of reflections. <br><br>I was fortunate to gain exposure 
                            for my art early on, holding independent exhibits at the ages of 16 and 17 and being featured in two newspaper articles 
                            in Calgary, AB. However, I took several years to step back, foster a deeper connection to my art, and reevaluate my 
                            relationship with it. Now, with a clearer vision of what I want, I am working towards showcasing my work once again. 
                            You can explore more of my work on my art website: http://www.natalieslaba.com.
                        </p>
                        <img src="art.jpg" alt="Visual Arts">
                    </div>
                    <div class="about-section">
                        <h3>Outdoors</h3>
                        <p>I love being outside, especially when engaging in sports that challenge and humble me. In recent years, I've become very passionate about climbing. I still feel like a beginner, which I love because there's always room to climb harder, improve, and learn more; there seems to be no mastery. It's a beautiful and humbling experience, knowing there is so much potential for growth. Additionally, I enjoy backcountry skiing and finding other ways to immerse myself in the mountains."
                        </p>
                        <!-- <img src="skiing.jpg" alt="Outdoors"> -->
                        <img src="climbing.jpg" alt="Outdoors">
                    </div>
                </div>
            </section>
        </main>
    
     
    
    <script id="vertex-shader" type="x-shader/x-vertex">#version 300 es
             
        in vec4 a_position;
        
        out vec2 v_uv;
        void main() {
            
            v_uv = a_position.xy * 0.5 + 0.5; // normalize to [0,1]
            gl_Position = a_position;
        }
    </script>
    <script id="fragment-shader" type="x-shader/x-fragment">#version 300 es
        precision mediump float;

        uniform vec2 u_resolution;
        uniform float u_time;
        uniform vec2 u_mouse;
        uniform int u_clicked;

        in vec2 v_uv; 
        out vec4 outColor;

        #define SMOOTH_STEP(a,b,t) smoothstep(a,b,t)
        #define ROTATION_ANGLE -0.785398
        #define SCALE .25
        #define SHOOTING_STAR_VELOCITY 2.

       // Signed Distance Function for the Mandelbulb
        float mandelbulbSDF(vec3 p) {
            const int maxIterations = 4;
            const float power = 9.0;
            vec3 z = p;
            float dr = 1.0;  // Derivative for distance estimation
            float r = 0.0;
        
            for (int i = 0; i < maxIterations; i++) {
                r = length(z);
                if (r > 3.0) break;
            
                // Convert to spherical coordinates
                float theta = acos(z.z / r);
                float phi = atan(z.y, z.x);
                dr = pow(r, power - 1.0) * power * dr + 1.0;
            
                // Scale and rotate
                float zr = pow(r, power);
                theta *= power;
                phi *= power;
            
                // Convert back to Cartesian coordinates
                z = zr * vec3(sin(theta) * cos(phi), sin(theta) * sin(phi), cos(theta)) + p;
            }
        
            // Return the signed distance
            return 0.5 * log(r) * r / dr;
        }

        // Normal calculation using finite differences
        vec3 calculateNormal(vec3 p, float epsilon) {
            vec2 e = vec2(epsilon, 0.0);
            return normalize(vec3(
                mandelbulbSDF(p + e.xyy) - mandelbulbSDF(p - e.xyy), // x-derivative
                mandelbulbSDF(p + e.yxy) - mandelbulbSDF(p - e.yxy), // y-derivative
                mandelbulbSDF(p + e.yyx) - mandelbulbSDF(p - e.yyx)  // z-derivative
            ));
        }

        float sdSegment(vec2 p, vec2 a, vec2 b) {
            vec2 pa = p - a;
            vec2 ba = b - a;
            float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);
            return length(pa - ba * h);
        }

        vec2 rotate(vec2 v, float a) {
            float c = cos(a), s = sin(a);
            return vec2(c * v.x - s * v.y, s * v.x + c * v.y);
        }

        float fbm(vec3 p) {
            float f = 0.0;
            f += 0.5 * sin(p.x * 3.0 + u_time * 0.5);
            f += 0.25 * sin(p.y * 5.0 + u_time);
            f += 0.125 * sin(p.z * 7.0 + u_time * 1.3);
            return f;
        }

        

        void main() {
            // programmer side
           if (v_uv.x < 0.4) {
           //    
           //     vec2 p = v_uv;
           //     vec3 col = vec3(0.0);
//
           //     vec2 origin = vec2(0.395, 0.48); // Start in center by Mandelbulb
//
           //     float angleSpread = 0.5; // radians between branches
           //     float initialLength = 0.11;
           //     int maxDepth = int(mix(0.0, 130.0, 1.0 - u_mouse.x * 3.0)); // deeper when mouse is left
//
           //     // Manual stack (iterative)
           //     const int MAX = 128;
           //     vec2 starts[MAX];
           //     vec2 dirs[MAX];
           //     float lens[MAX];
//
           //     int count = 0;
           //     starts[count] = origin;
           //     dirs[count] = vec2(-1.0, 0.0); // grow left
           //     lens[count] = initialLength;
           //     count++;
//
           //     for (int i = 0; i < MAX; i++) {
           //         if (i >= count || i >= maxDepth) break;
           //     
           //         vec2 a = starts[i];
           //         vec2 dir = dirs[i];
           //         float len = lens[i];
           //         vec2 b = a + dir * len;
           //     
           //         float d = sdSegment(p, a, b);
           //         if (d < 0.0015) {
           //             col = vec3(1.0-u_mouse.x*3.0); // white line
           //         }
           //     
           //         if (count + 2 < MAX) {
           //             vec2 leftDir  = rotate(dir,  angleSpread);
           //             vec2 rightDir = rotate(dir, -angleSpread);
           //         
           //             starts[count] = b;
           //             dirs[count]   = leftDir;
           //             lens[count]   = len * 0.95;
           //             count++;
           //         
           //             starts[count] = b;
           //             dirs[count]   = rightDir;
           //             lens[count]   = len * 0.95;
           //             count++;
           //         }
           //     }
           // 
           //     outColor = vec4(col, 1.0);
//
           // }

            


            // art side
            if (v_uv.x > 0.5){
                
                //// Raymarch iterator, step distance, depth and reflection
                //float i, d, z, r = 0.0;
//
                //// Clear color
                //outColor *= i;
//
                //// Raymarch 90 steps
                //for (i = 0.0; i < 90.0; i++) {
                //
                //    // Ray direction
                //    vec3 dir = normalize(vec3((v_uv.x-u_mouse.x+0.3) * 2.0 - 1.0,(v_uv.y) * 2.0 - 1.0, -1.0));
                //    // Camera position slightly offset back
                //    vec3 p = vec3(0.0, 0.0, 2.5) + z * dir;
                //    
                //    // Signed distance to a sphere, slightly organic
                //    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;
                //    sphere -= 0.6 * sin(6.0 * p.x*u_mouse.x + u_time);
                //    sphere -= 0.4 * sin(6.0 * p.z + u_time * 1.1);
                //    sphere -= 0.3 * sin(6.0 * p.z + u_time * 0.9);
                //
                //    d = sphere;
                //
                //    if (d < 0.01) {
                //        // Color when close to the surface
                //        float y = 0.1 + (u_mouse.x - 0.5) * 1.8; //remap
                //        vec3 col = vec3(y + 0.5*sin(u_time + z*2.0), y + 0.3*cos(z*3.0), y + 0.5*sin(u_time + z*2.0));
                //        
                //        outColor += vec4(col, 1.0) * (y);
                //        break;
                //    }
                //
                //    // Step forward
                //    z += d;
                //
                //    // Attenuate if too far
                //    if (z > 8.0) break;
                //}
//
                //
                //if (u_mouse.x <0.5){
                //    outColor =vec4(0.0);
                //} else {
                //    // Tone mapping
                //    outColor = tanh(outColor);
                //}
                float i, d, z = 0.0;
                

                for (i = 0.0; i < 90.0; i++) {
                    vec3 dir = normalize(vec3((v_uv.x - 1.0) * 2.0, (v_uv.y - 0.5) * 2.0, -1.0));

                    //vec3 dir = normalize(vec3((v_uv.x - u_mouse.x + 0.3) * 2.0 - 1.0,
                      //                        (v_uv.y) * 2.0 - 1.0,
                        //                      -1.0));
                    vec3 p = vec3(0.0, 0.0, 2.5) + z * dir;
                
                    // Add some noise-based wobble for organic feel
                    float dist = length(p - vec3(0.0)) - 0.5;
                    dist += fbm(p * 2.0);
                
                    d = dist;
                
                    if (d < 0.01) {
                        float y = 0.1 + (u_mouse.x - 0.5) * 1.8; // remap
                    
                        // Paint-like blended colors
                        vec3 col = vec3(
                            0.6 + 0.8 * sin(z * 2.5 + u_time * 1.8),
                            0.5 + 0.5 * cos(z * 3.5 - u_time * 1.4),
                            0.4 + 0.6 * sin(z * 1.5 + u_time * 0.9)
                        );
                    
                        // Blend in color with softness
                        outColor += vec4(col * smoothstep(0.01, 0.0, d), 1.0) * y;
                        break;
                    }
                
                    z += d * 0.5; // slower steps = more blobby
                
                    if (z > 8.0) break;
                }
            
                // Only show if mouse is on right half
                if (u_mouse.x < 0.5) {
                    outColor = vec4(0.0);
                } else {
                    // Soft tone mapping
                    outColor = vec4(tanh(outColor.rgb), 1.0);
                }

        } 
            
            // outColor = outColor;
            
            // Normalize screen coordinates
            //vec2 uv = v_uv * 2.0 - 1.0;  // from [0,1] to [-1,1]
            // Shrink Mandelbulb to 1/20th size and move to top-left
            vec2 miniUV = (v_uv - vec2(0.19, 0.20)) * 1.6;  // 50% of screen = 1/2
            vec2 uv = miniUV * 2.0 - 1.0;  // map [0,1] â†’ [-1,1]
            uv.x *= u_resolution.x / u_resolution.y;  // correct aspect ratio

            
            // Camera setup
            vec3 camPos = vec3(0.0, 0.0, 2.0);
            vec3 lookAt = vec3(0.0, 0.0, 0.0);
            vec3 forward = normalize(lookAt - camPos);
            vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));
            vec3 up = cross(forward, right);
            vec3 rayDir = normalize(forward + uv.x * right + uv.y * up);
            
            // Ray marching parameters
            float totalDist = 0.0;
            const int maxSteps = 600;
            const float maxDist = 80.0;
            float surfaceEpsilon = 0.001;
            
            vec3 hitPos;
            bool hit = false;
            vec3 deform = vec3(0.0);
            
            for (int i = 0; i < maxSteps; i++) {
                vec3 pos = camPos + totalDist * rayDir;
                float dist = mandelbulbSDF(pos);
                if (dist < surfaceEpsilon) {
                    hit = true;
                    
                    //if (u_clicked == 1) {
                    //    deform = vec3(u_mouse*0.1, 0.0);
                    //}
                    hitPos = pos-deform;
                    break;
                }
                totalDist += dist;
                if (totalDist > maxDist) break;
            }
        
            // Basic background color
            vec3 color = vec3(0.0);
        
            if (hit) {
                // Compute the normal at the hit position
                vec3 normal = calculateNormal(hitPos, surfaceEpsilon);
            
                // Simple lighting: directional light
                vec3 lightDir = normalize(vec3(cos(u_time), cos(u_time), sin(u_time)));
                float diffuse = max(dot(normal, lightDir), 0.0);
            
                // Shading with a gradient
                if (u_mouse.x>0.5){
                    color = mix(vec3(0.1, 0.1, 0.4)*(1.5-u_mouse.x), vec3(0.9, 0.8, 1.0)*(1.5-u_mouse.x), diffuse);
                } else {
                    color = mix(vec3(0.1, 0.1, 0.4), vec3(0.9, 0.8, 1.0), diffuse);
                }
                
                
            }
        
            outColor += vec4(color, 1.0);
            
        
        }

       
   
        
    </script>
    <script src="scripts.js"></script>
</body>
</html>



